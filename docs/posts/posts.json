[
  {
    "path": "posts/2021-04-06-peixes-dashboard/",
    "title": "Peixes Dashboard",
    "description": "Aplicação Shiny de acompanhamento de programas de marcação de peixes.",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-06-20",
    "categories": [
      "ShinyApp",
      "R"
    ],
    "contents": "\r\nEsta aplicação Shiny foi desenvolvida como exemplo de um modelo para acompanhar projetos de marcação de peixes.\r\nOs dados usados foram invetados, o passo a passo da criação dos dados pode ser vista no arquivo dados.R.\r\nAs visualizações e as entradas (inputs) foram escolhidos apenas para demostrar o funcionamento do aplicativo.\r\nO funcionamento do aplicativo pode ser visto no GIF abaixo:\r\n\r\n\r\n\r\nA aplicação está disponível em:\r\nhttps://leonardodonatonunes.shinyapps.io/PeixesMarcados_Shiny/\r\nO código fonte pode ser visto em:\r\nhttps://github.com/LeonardoDonatoNunes/PeixesMarcados_Shiny\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-04-06-peixes-dashboard/img/Shiny_app.gif",
    "last_modified": "2021-04-06T11:26:57-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-lgpd/",
    "title": "LGPD",
    "description": "Breve resumo sobre a Lei Geral de Proteção de Dados",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-02-28",
    "categories": [
      "LGPD"
    ],
    "contents": "\r\n\r\n\r\nShow code\r\n\r\nlibrary(png)\r\nlibrary(grid)\r\nlibrary(gridExtra)\r\nlibrary(ggplot2)\r\nlibrary(ggthemes)\r\nimg1 <-  rasterGrob(as.raster(readPNG(\"..\\\\..\\\\img\\\\lgpd.png\")), interpolate = FALSE)\r\nimg2 <- ggplot(data = NULL) +\r\n  annotate(\"text\", x = 0, y = 0, label = \"Lei Geral de Proteção de Dados\", hjust = 0) +\r\n  annotate(\"text\", x = 0, y = -0.1, label = \"Lei nº 13.709/2018\", hjust = 0) +\r\n  annotate(\"text\", x = 0, y = -0.2, label = \"Medida Provisória nº 869/2018\", hjust = 0) +\r\n  annotate(\"text\", x = 0, y = -0.3, label = \"Convertida em Lei nº 13.853/19\", hjust = 0) +\r\n  xlim(c(0,2)) +\r\n  theme_map()\r\ngrid.arrange(img1, img2, ncol = 2)\r\n\r\n\r\n\r\n\r\n\r\nA LGPD é a lei que regula todo tratamento de dados pessoais dos cidadãos brasileiros dentro e fora do Brasil. Se aplica aos meios físicos e digitais. Tem a missão de proteger os direitos fundamentais: Liberdade; Privacidade; Livre desenvolvimento e Pesonalidade. É baseada no Regulamento Geral de Proteção de Dados da União Européia que criou regras claras sobre os processos de coleta, armazenamento e compartilhamentos de informações. Na prática, geverno e empresas terão que garantir maior segurança aos dados pessoais.\r\nO objetivo deste artigo é um fazer um histórico e resumo da lei. O artigo foi inspirado em uma aula de Legislação no Ambiente Digital (LGPD) do MBA em Data Science & Analytics da USP/ESALQ ministrada pela professora Núria López. Além das aulas também foram pesquisadas informações nos sites oficiais do governo federal, como a página sobre LGPD do ministério da defesa, nas leis e decretos publicados e da página sobre LGPD da Serpro (Serviço Federal de Processamento de Dados).\r\nHistórico de criação da LGPD\r\nA LGPD possui três datas de vigência, a primeira é de dezembro de 2018, quando foi sancionada entraram em vigor as leis que definem a Agencia Nacional de Proteção de Dados (ANPD), que só foi instituida em agosto de 2020 através do decreto nº 10.474/20. A lei entrou em vigor em setembro de 2020, porém, as penalidades só podem ser aplicadas em agosto de 2021.\r\n\r\n\r\nShow code\r\n\r\nmeses <- seq.Date(as.Date(\"2018-10-01\"), as.Date(\"2022-01-01\"), by = \"month\")\r\n\r\n\r\nggplot(data = NULL, aes(x = meses, y = 0)) +\r\n  geom_hline(yintercept = 0) +\r\n  geom_point(aes(x = c(as.Date(\"2018-12-01\"), as.Date(\"2020-09-01\"), as.Date(\"2021-08-01\")),\r\n                 y = c(0,0,0)), size = 8, col = alpha(\"blue\", alpha = 0.3)) +\r\n  annotate(\"text\", x = as.Date(\"2018-12-01\"), y = -0.2, label = \"Dez/2018 \\n ANPD\", size = 5) +\r\n  annotate(\"text\", x = as.Date(\"2020-09-01\"), y = -0.2, label = \"Set/2020 \\n Vigência LGPD\", size = 5) +\r\n  annotate(\"text\", x = as.Date(\"2021-08-01\"), y = -0.2, label = \"Ago/2021 \\n Aplicações de sanções \\n pela ANPD\", size = 5) +\r\n\r\n  xlim(c(as.Date(\"2018-10-01\"), as.Date(\"2022-01-01\"))) +\r\n  ylim(c(-0.5, 0.1)) +\r\n  theme_map()\r\n\r\n\r\n\r\n\r\nA Lei Geral de Proteção de Dados Pessoais (LGPD), Lei nº 13.709, de 14 de agosto de 2018, dispõe sobre o tratamento de dados pessoais, inclusive nos meios digitais, por pessoa natural ou por pessoa jurídica de direito público ou privado, com o objetivo de proteger os direitos fundamentais de liberdade e de privacidade e o livre desenvolvimento da personalidade da pessoa natural.\r\nPara proteger os direitos fundamentais de liberdade e privacidade e o livre desenvolvimento da personalidade da pessoa natural foi criada a Autoridade Nacional de Proteção de Dados (ANPD), conforme estabelecido no Decreto nº 10.474, de 26 de agosto de 2020.\r\nDefinições\r\nDado Pessoal\r\nDado pessoal é qualquer dado capaz de identificar alguém, pode ser email, CEP, telefone, endereço, IP, dado de compra, geolocalização, Cookie ID, número do cartão, e qualquer outro dado que posssa ser usado para identificação pessoal. Ou seja, o conceito de dado pessoal é dinâminco, dependendo da capacidade de análise. Qualquer dados pode ser um potencial dado pessoal.\r\nDado pessoal sensível\r\nSão dados que exigem um pouco mais de atenção: são os sobre crianças e adolescentes; e os “sensíveis”, que são os que revelam origem racial ou étnica, convicções religiosas ou filosóficas, opiniões políticas, filiação sindical, questões genéticas, biométricas e sobre a saúde ou a vida sexual de uma pessoa.\r\nTexto obtido em https://www.serpro.gov.br/lgpd/menu/protecao-de-dados/dados-sensiveis-lgpd. Data do acesso: 28 de fevereiro de 2021.\r\nTratamento de dados\r\nToda operação realizada com dados pessoais; como as que se referem a:\r\n\r\n\r\n\r\nacesso - possibilidade de comunicar-se com um dispositivo, meio de armazenamento, unidade de rede, memória, registro, arquivo etc., visando receber, fornecer, ou eliminar dados\r\narmazenamento - ação ou resultado de manter ou conservar em repositório um dado\r\narquivamento - ato ou efeito de manter registrado um dado embora já tenha perdido a validade ou esgotada a sua vigência\r\navaliação - ato ou efeito de calcular valor sobre um ou mais dados\r\nclassificação - maneira de ordenar os dados conforme algum critério estabelecido\r\ncoleta - recolhimento de dados com finalidade específica\r\ncomunicação - transmitir informações pertinentes a políticas de ação sobre os dados\r\ncontrole - ação ou poder de regular, determinar ou monitorar as ações sobre o dado\r\ndifusão - ato ou efeito de divulgação, propagação, multiplicação dos dados\r\ndistribuição - ato ou efeito de dispor de dados de acordo com algum critério estabelecido\r\n\r\n\r\n\r\n\r\neliminação - ato ou efeito de excluir ou destruir dado do repositório\r\nextração - ato de copiar ou retirar dados do repositório em que se encontrava\r\nmodificação - ato ou efeito de alteração do dado\r\nprocessamento - ato ou efeito de processar dados\r\nprodução - criação de bens e de serviços a partir do tratamento de dados\r\nrecepção - ato de receber os dados ao final da transmissão\r\nreprodução - cópia de dado preexistente obtido por meio de qualquer processo\r\ntransferência - mudança de dados de uma área de armazenamento para outra, ou para terceiro\r\ntransmissão - movimentação de dados entre dois pontos por meio de dispositivos elétricos, eletrônicos,\r\ntelegráficos, telefônicos, radioelétricos, pneumáticos etc.\r\nutilização - ato ou efeito do aproveitamento dos dados\r\n\r\n\r\n\r\nTexto obtido em https://www.serpro.gov.br/lgpd/menu/a-lgpd/glossario-lgpd. Data do acesso: 28 de fevereiro de 2021.\r\nA quem se aplica a LGPD\r\nMeios Físico e Digital para:\r\nTratamentos de dados realizados no Brasil\r\nBens e serviços oferecidos ou fornecidos no Brasil\r\nTratamento de dados coletados no Brasil\r\nTratamento de dados de indivíduos localizados no Brasil\r\nOs 7 princípios do Privacy by design\r\nOs sete princípios da privacidade por definição (tradução livre) foram elaborados pela Dra. Ann Cavoukian e puplicados pela Comissão de Informação e Privacidade de Ontário, Canadá.\r\nPró-ativo não reativo:\r\nUma vez que o dados está disponibilizado, é quase impossível voltar atrás.\r\nPrivacidade como configuração padrão:\r\nPrivacidade precisa vir por padrão, solicitar consentimento para todo dado coletado.\r\nPrivacidade incorporada ao design, incluindo a arquitetura e modelos de negócio:\r\nA privacidade precisa ser vista como um benefício ao design.\r\nFuncionalidade total - soma positiva, não soma zero:\r\nA privacidade soma a funcionalidade.\r\nSegurança de ponta a ponta: proteção completa incorporada ao ciclo de vida da informação;\r\nSem elos de vulnerabilidade.\r\nVisibilidade e transparência - mantê-lo aberto:\r\nAutodeterminação informativa: cada um de nos temos direito do controle dos nossos dados pessoais.\r\nRespeito pela privacidade do usuário: mantê-lo centrado nos interesses do usuário.\r\nConsiderações\r\nNa prática, para os profissionais que trabalham com dados, a LGPD estabelece regras para a coleta, armazenamento, tratamento e análise de dados pessoais, para isso devemos seguir os princípios da privacidade por definição (Privacy by design), que foram elaborados para que possamos pensar em privacidade de dados desde o início do projeto. O que precisamos ter em mente é que os dados que iremos coletar, precisam atender a finalidades específicas para cada informação coletada, e os consentimentos devem ser solicitados para cada uma delas.\r\n\r\nBack to top\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-05-lgpd/lgpd_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-03-11T21:49:24-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-materiais/",
    "title": "Links para Conteúdos de DS",
    "description": "Lista de links de livros, sites, cais do youtube sobre Data Science.",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-02-28",
    "categories": [
      "Livros"
    ],
    "contents": "\r\n\r\nContents\r\nCanais, vídeos e playlists \r\nSites e blogs \r\nLivros \r\nPacotes \r\nRepositórios e páginas \r\nGeral \r\n\r\n\r\n\r\n\r\nEste post foi criado para agregar conteúdos de Data Science através de Links que levam a páginas, livros, canais e vídeos que tem relação com Data Science. Os assuntos estão organizados por tópicos que podem ser acessados rolando a página ou na tabela de conteúdos.\r\nCanais, vídeos e playlists \r\nMachine Learning Meetups - Nubank\r\nWorking with Spark - RStudio\r\nRStudio Webinars\r\nCálculo I - Unicamp/Univesp\r\nSites e blogs \r\nFont Awesome\r\nCreate Awesome HTML Table with knitr::kable and kableExtra\r\nRegex: Um guia prático para expressões regulares\r\nrOpenSci\r\nSpatial Data Science\r\nLatex - Notações matemáticas\r\nLivros \r\nR Markdown: The Definitive Guide\r\nAnálise de Dados Financeiros e Econômicos com o R\r\nB3 + rvest: Explorando dados financeiros com R\r\nMastering Shiny\r\nMastering Spark with R\r\nPacotes \r\nDistill for R Markdown\r\nIntroduction to data.tree\r\nsparklyr: R interface for Apache Spark\r\nMastering Shiny\r\nshinyMobile\r\nRinteRface\r\nRepositórios e páginas \r\nMichael Clark\r\nGeral \r\nFiz uma pesquisa sobre como criar uma página distill com {.tabset} e umas das respostas do link abaixo resolveu meu problema.\r\nDistill - com tabset\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-05-materiais/materiais_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-04-05T22:04:57-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-rmarkdown/",
    "title": "RMarkdown",
    "description": "Conteúdos sobre RMarkdown.",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-02-28",
    "categories": [
      "R",
      "Livros",
      "RMarkdown"
    ],
    "contents": "\r\n\r\nContents\r\nCódigos\r\nComo criar um novo chunk de código\r\nCriar colunas\r\n\r\nLivros\r\n\r\n\r\n\r\n\r\nEste post é um guia de códigos e materiais sobre o RMarkdown. São os códigos que mais utilizo nos meus documentos.\r\nCódigos\r\nComo criar um novo chunk de código\r\nPara inserir um novo bloco de código, você pode ir na barra de ferramentas do RStudio e clicar no botão de inserir código (Insert a new code chunk) e escolher o bloco de código da linguagem desejada. Como mostrado na imagem abaixo. Ou pelo atalho do teclado \\(Ctrl + Alt + I\\).\r\n\r\n\r\n\r\nCriar colunas\r\nPara criar colunas no corpo do documento precisa especificar o quanto cada coluna vai ocupar na página. No arquivo de estico .css, ou na própria página com as tags de estilo, configurar o tamanho das colunas dependendo do número de colunas inserido. Neste exemplo, criei uma classe para duas colunas = .column, e para três colunas = .column_3. No exemplo abaixo usei a classe column para cruar duas colunas, se for criar três ou mais colunas, trocar a classe.\r\n\r\n<style>\r\n  \r\n      /* configuracao das colunas no texto */ \r\n    /* 2 colunas */ \r\n    .column{\r\n      float: left;\r\n      width: 48%;\r\n      text-align: left;\r\n    }\r\n    \r\n    /* 3 colunas */ \r\n    .column_3{\r\n      float: left;\r\n      width: 33.33%;\r\n      text-align: left;\r\n    }\r\n  \r\n<\/style>\r\n\r\n:::::: {.cols data-latex=\"\"}\r\n\r\n::: {.column}\r\n\r\n  **Texto da primeira coluna**  Texto ou blocos de código da primeira coluna.  \r\n  \r\n:::\r\n\r\n::: {.column}\r\n\r\n  **Texto da segunda coluna**  Texto ou blocos de código da segunda coluna.\r\n\r\n:::\r\n\r\n::::::\r\n\r\n\r\n\r\nTexto da primeira coluna Texto ou blocos de código da primeira coluna.\r\n\r\n\r\nTexto da segunda coluna Texto ou blocos de código da segunda coluna.\r\n\r\n\r\nLivros\r\nR Markdown Cookbook - The R Series\r\nAutores: Yihui Xie, Christophe Dervieux, Emily Riederer\r\nVoltar ao topo\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-05-rmarkdown/rmarkdown_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-03-11T22:26:39-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-postgis/",
    "title": "PostGIS",
    "description": "Criação de um Banco de Dados Espacial PostGIS com o R e Rstudio",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-02-24",
    "categories": [
      "BD",
      "PostGIS",
      "R"
    ],
    "contents": "\r\n\r\n\r\n\r\nO PostGIS é uma extensão do PostgreSQL para armazenamento, gerenciamento, tratamento e análise de dados espaciais. Em comparação com um banco de dados padrão, que contém textos, números e datas, um banco de dados espacial contém tipos adicionais de dados para representar feições geográficas. Esses tipos de dados espaciais abstraem e encapsulam estruturas espaciais, como limite e dimensão. Em muitos aspectos, os tipos de dados espaciais podem ser entendidos simplesmente como formas. Os tipos de dados espaciais são organizados em uma hierarquia de tipos (Figura 1). Cada subtipo herda a estrutura (atributos) e o comportamento (métodos ou funções) de seu supertipo. A página do PostGIS contém uma documentação bem extensa para aprendizado. Também existe um manual em português.\r\n\r\n\r\n\r\nFigura 1. Hierarquia de feições geográficas. Imagem obtida e traduzida da página de introdução do PostGIS.\r\nOs bancos de dados comuns providenciam métodos de acessar os dados, conhecidos como index, que permitem acesso rápido a conjuntos aleatórios de dados. Indexar os dados padrão (texto, número, datas) é normalmente feito com B-tree índice, que particiona os dados em uma hierarquia natural ordenados em forma de árvore (tree) hierárquica. Porém o indice B-tree não pode ser facilmente usado para feições geométricas, para isso o índice usado é o spacial index, que tenta identificar que tipo de feição está dentro de cada “caixa” (retângulo com a extensão da feição).\r\nNeste documento, irei criar um banco de dados geográficos PostGIS e adicionar uma tabela com dados espaciais. Os códigos SQL serão enviados ao PostgreSQL através do R, com a função dbGetQuery do pacote RPostgreSQL\r\nBreve introdução ao RPostgreSQL\r\nAntes de começar a falar de PostGIS, segue uma breve introdução ao funcionamento do RPostgreSQL.\r\nO primeiro passo é criar uma conexão com o banco de dados que vamos trabalhar, neste exemplo usarei o BD criado quando o Postgres é instalado. Tmabém usei a senha e usuário padrões.\r\nCarregar os pacotes\r\n\r\n\r\nlibrary(rpostgis)\r\nlibrary(raster)\r\nlibrary(rgdal)\r\nlibrary(RPostgreSQL)\r\n\r\n\r\n\r\nCria um driver Postgres\r\n\r\n\r\ndrv <- dbDriver(\"PostgreSQL\")\r\n\r\n\r\n\r\nCriando a conexão com o servidor\r\n\r\n\r\ncon <- dbConnect(drv,\r\n                 dbname = \"postgres\",\r\n                 host = \"localhost\",\r\n                 port = 5432, \r\n                 user = \"postgres\",\r\n                 password =  \"postgres123\") \r\n\r\n\r\n\r\nFunções do RPostgreSQL\r\nO pacote possui algums funções para acessar e criar tabelas do BD.\r\nSeguem alguns exemplos:\r\nPara listar as tabelas do BD\r\n\r\n\r\ndbListTables(con)\r\n\r\n\r\n [1] \"investidor\"                     \"investimento\"                  \r\n [3] \"startup\"                        \"cidade\"                        \r\n [5] \"obitos\"                         \"escolaridade\"                  \r\n [7] \"estado_civil\"                   \"public.nova_tabela\"            \r\n [9] \"nova_tabel\"                     \"public.nova_tabela_2\"          \r\n[11] \"spatial_ref_sys\"                \"public.tabela_coordenadas\"     \r\n[13] \"public.tabela_coordenada\"       \"area\"                          \r\n[15] \"obitos_brasil_sim.escolaridade\" \"obitos_brasil_sim.est_civil\"   \r\n[17] \"nova_tabela_2\"                  \"tabela_coordenadas\"            \r\n[19] \"public.area\"                   \r\n\r\nListar os campos em uma tabela específica\r\n\r\n\r\ndbListFields(conn = con, name = \"investimento\")\r\n\r\n\r\n[1] \"id\"             \"startup_id\"     \"investidor_id\" \r\n[4] \"valor\"          \"data_realizada\" \"obs\"           \r\n\r\nCarregra uma tabela do BD\r\n\r\n\r\ninvestimento <- dbReadTable(con, \"investimento\")\r\nhead(investimento, 3)\r\n\r\n\r\n  id startup_id investidor_id     valor data_realizada  obs\r\n1  1          1             1 200000000     2020-01-09 <NA>\r\n2  2          2             2   8048394     2020-01-13 <NA>\r\n3  3          3             3  18358860     2020-01-09 <NA>\r\n\r\nPara inserir uma nova tabela no BD, desta vez eu expecifiquei qual schema a tabela será criada. No argumento “nome”: c(“schema”,“tabela”).\r\n\r\n\r\nnova_tabela <- data.frame(\"id\" = 1:5, nomes = LETTERS[1:5])\r\ndbWriteTable(con, name =c(\"public\", \"nova_tabela\"), value = nova_tabela)\r\n\r\n\r\n[1] TRUE\r\n\r\ndbReadTable(con, name = c(\"public\", \"nova_tabela\"))\r\n\r\n\r\n  id nomes\r\n1  1     A\r\n2  2     B\r\n3  3     C\r\n4  4     D\r\n5  5     E\r\n\r\nUma outra maneira de fazer consultas é enviando uma SQL Query:\r\nPara excluir uma tabela do BD\r\n\r\n\r\ndbGetQuery(conn = con, statement = \"DROP TABLE IF EXISTS public.nova_tabela ;\")\r\n\r\n\r\ndata frame with 0 columns and 0 rows\r\n\r\nPara selecionar uma tabela\r\n\r\n\r\ndbGetQuery(conn = con, statement = \"SELECT * FROM investimento LIMIT 3;\")\r\n\r\n\r\n  id startup_id investidor_id     valor data_realizada  obs\r\n1  1          1             1 200000000     2020-01-09 <NA>\r\n2  2          2             2   8048394     2020-01-13 <NA>\r\n3  3          3             3  18358860     2020-01-09 <NA>\r\n\r\nPara criar uma tabela no BD\r\n\r\n\r\ndbGetQuery(conn = con, statement = \"DROP TABLE IF EXISTS public.nova_tabela_2;\")\r\n\r\n\r\ndata frame with 0 columns and 0 rows\r\n\r\ndbGetQuery(conn = con, statement = \"CREATE TABLE public.nova_tabela_2(\r\n           id integer,\r\n           nomes varchar\r\n           );\")\r\n\r\n\r\ndata frame with 0 columns and 0 rows\r\n\r\nPara inserir dados na tabela criada\r\n\r\n\r\ndbWriteTable(con, \"nova_tabela_2\", nova_tabela, row.names=FALSE, append=TRUE)\r\n\r\n\r\n[1] TRUE\r\n\r\nViualizas as linhas inseridas\r\n\r\n\r\ndbGetQuery(conn = con, statement = \"SELECT * FROM nova_tabela_2;\")\r\n\r\n\r\n  id nomes\r\n1  1     A\r\n2  2     B\r\n3  3     C\r\n4  4     D\r\n5  5     E\r\n\r\nDesconectar do bd\r\n\r\n\r\ndbDisconnect(con)\r\n\r\n\r\n[1] TRUE\r\n\r\nCriando a extensão PostGIS\r\nCarregar o pacote\r\n\r\n\r\nlibrary(\"RPostgreSQL\")\r\n\r\n\r\n\r\nCria um driver Postgres\r\n\r\n\r\ndrv <- dbDriver(\"PostgreSQL\")\r\n\r\n\r\n\r\nCriando a conexão com o servidor\r\n\r\n\r\ncon <- dbConnect(drv,\r\n                 dbname = \"postgres\",\r\n                 host = \"localhost\",\r\n                 port = 5432, \r\n                 user = \"postgres\",\r\n                 password =  \"postgres123\") \r\n\r\n\r\n\r\nCria a extensão:\r\n\r\n\r\ndbGetQuery(conn = con, statement = \"CREATE EXTENSION postgis;\")\r\n\r\n\r\n\r\nPara carregar dados de uma tabela contendo coordenadas e armazenar estes dados como feição no BD primeiro é preciso criar uma função no SQL para criar a geomeria.\r\nAbaixo criei um schema de funções e uma função para criar uma feição do tipo ponto sempre que um novo registro contendo campos de lon (longitude) e lat (latitude forem adicionados)\r\n\r\n\r\ndbGetQuery(conn = con, statement = \"CREATE SCHEMA funcoes;\")\r\n\r\ndbGetQuery(conn = con, statement = \"CREATE OR REPLACE FUNCTION \r\nfuncoes.create_geom_points()\r\nRETURNS trigger AS \r\n$BODY$\r\nDECLARE\r\n  thegeom geometry;\r\nBEGIN\r\n\r\nIF NEW.lon IS NOT NULL AND NEW.lat IS NOT NULL THEN\r\n  thegeom = ST_SetSRID(ST_MakePoint(NEW.lon, NEW.lat),4326);\r\n  NEW.geom = thegeom;\r\nEND IF;\r\n\r\nRETURN NEW;\r\nEND;$BODY$\r\nLANGUAGE plpgsql VOLATILE\r\nCOST 100;\r\nCOMMENT ON FUNCTION funcoes.create_geom_points()\r\nIS 'When called by a trigger (insert_lon_lat) \r\nthis function populates the field geom \r\nusing the values from lon and lat fields.';\")\r\n\r\n\r\n\r\nCriar uma tabela contendo pontos com coordenadas\r\n\r\n\r\ntabela_coordenadas <- data.frame(id = 1:5, \r\n              lon = c(-48.08534, -48.02049,-48.01342,-47.87874,-47.90576), \r\n              lat = c(-20.67190, -20.63615,-20.75088,-20.76834,-20.67439))\r\n\r\n\r\n\r\nCria a tabela no BD e executa a função “create_geom_points()”\r\n\r\n\r\ndbGetQuery(con, \"DROP TABLE IF EXISTS public.tabela_coordenadas CASCADE;\")\r\n\r\n\r\ndata frame with 0 columns and 0 rows\r\n\r\ndbGetQuery(con, \"CREATE TABLE public.tabela_coordenadas(\r\nid integer,\r\nlon double precision,\r\nlat double precision,\r\ngeom geometry(Point, 4326));\")\r\n\r\n\r\ndata frame with 0 columns and 0 rows\r\n\r\ndbGetQuery(con, \"CREATE TRIGGER inserir_lon_lat\r\n           BEFORE INSERT\r\n           ON public.tabela_coordenadas\r\n           FOR EACH ROW\r\n           EXECUTE PROCEDURE funcoes.create_geom_points();\")\r\n\r\n\r\ndata frame with 0 columns and 0 rows\r\n\r\ndbWriteTable(con, c(\"public\", \"tabela_coordenadas\"), tabela_coordenadas, row.names=FALSE, append=TRUE)\r\n\r\n\r\n[1] TRUE\r\n\r\nObserve que agora foi criada uma feição\r\n\r\n\r\ndbGetQuery(con, \"SELECT * FROM public.tabela_coordenadas;\")\r\n\r\n\r\n  id       lon       lat\r\n1  1 -48.08534 -20.67190\r\n2  2 -48.02049 -20.63615\r\n3  3 -48.01342 -20.75088\r\n4  4 -47.87874 -20.76834\r\n5  5 -47.90576 -20.67439\r\n                                                geom\r\n1 0101000020E61000003485CE6BEC0A48C0B22E6EA301AC34C0\r\n2 0101000020E610000091F2936A9F0248C0B459F5B9DAA234C0\r\n3 0101000020E6100000618E1EBFB70148C07138F3AB39C034C0\r\n4 0101000020E6100000F1D7648D7AF047C0693524EEB1C434C0\r\n5 0101000020E6100000320395F1EFF347C0DBBFB2D2A4AC34C0\r\n\r\nEsses dados podem ser usados direto no QGIS, acessando o BD, ou vizualizados no pgAdmin.\r\nPara inserir um arquivo no formato Shapefile:\r\nCarregar um arquivo .shp\r\n\r\n\r\narea <- shapefile(\"C:\\\\Users\\\\user\\\\Documents\\\\area.shp\")\r\n\r\n\r\n\r\nInserir o arquivo .shp no BD\r\n\r\n\r\npgInsert(con, c(\"public\",\"area\"), area, new.id = \"gid\")\r\n\r\n\r\n[1] TRUE\r\n\r\nPara obter as feições do BD pode ser utilizada a função “pgGetGeom”\r\n\r\n\r\narea <- pgGetGeom(con, c(\"public\",\"area\"))\r\npontos <- pgGetGeom(con, c(\"public\",\"tabela_coordenadas\"))\r\n\r\n\r\n\r\n\r\nBrasil, 24 de Fevereiro de 2021\r\n\r\nBack to top\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-05-postgis/postgis_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-03-11T20:08:24-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-pymongo/",
    "title": "PyMongo",
    "description": "Breve introdução ao PyMongo, um driver para acessar o MongoDB com Python",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-02-19",
    "categories": [
      "MongoDB",
      "BD",
      "Python",
      "NoSQL"
    ],
    "contents": "\r\n\r\n\r\n\r\nUm cientista de dados não precisa ser um desenvolverdor de banco de dados, porém, conhecimentos básicos de linguagem SQL e dos sistemas de gerenciamento de bancos de dados (SGBD) mais comuns, tanto relacionais quanto não relacionais, são importantes para a execução do trabalho diário. Geralmente, como cientistas de dados, trabalhamos com Python ou R, inclusive para fazer consultas e desenvolver bancos de dados. O objetivo desta publicação é fazer uma breve introdução a biblioteca PyMongo, um módulo Python para acessar o MongoDB. Para saber mais basta acessar a documentação do PyMongo\r\nO MongoDB é considerado o principal SGBD não-relacional (NoSQL; Not Only SQL). Diferente de um SGBD relacional, que trabalha com tabelas, colunas e linhas, que se relacionam através de chaves, o MongoDB trabalha com um formato flexivel de documento, similar a objetos JSON. Cada documento pode ser considerado como uma linha de uma tabela de um BD relacional, e os documentos são agrupados em coleções, que são como as tabelas, porém, cada documento pode variar em sua estrutura e ser alterado ao longo do tempo.\r\nNa página de aprendizado do MongoDB existe uma documentação bem extensa para quem deseja obter mais informações.\r\nAcessando o MongoDB\r\nImportar a biblioteca:\r\n\r\nfrom pymongo import MongoClient\r\nimport pprint\r\n\r\nCriar a conexão com o Mongo:\r\n\r\ncon = MongoClient('localhost', 27017)\r\n\r\nPara o exemplo, vou criar uma coleção chamada universidades, contendo quatro documentos\r\n\r\nuniversidades = [ {'nome': 'URGS', 'n_alunos': 15000},\r\n                  {'nome': 'UNB', 'n_alunos': 20000},\r\n                  {'nome': '', 'n_alunos': 9000},\r\n                  {'nome': 'USP', 'n_alunos': 30000} ]\r\n\r\nPara inserir os documentos em um BD. Note que o nome do BD é ‘instituicoes’. Caso o BD não exista, um BD chamado ‘instituicoes’ será criado, o mesmo para a coleção ‘universidades’.\r\n\r\nwith con:\r\n\r\n    db = con.instituicoes\r\n    \r\n    db.universidades.insert_many(universidades)\r\n<pymongo.results.InsertManyResult object at 0x000000003E4AAC80>\r\n\r\nListar os nomes dos bancos de dados:\r\n\r\ncon.list_database_names()\r\n['Vendas', 'admin', 'config', 'igti', 'instituicoes', 'local', 'vendas_automoveis']\r\n\r\nAcessar um banco de dados e buscar as colecoes\r\n\r\nbd = con.instituicoes\r\nprint(bd.list_collection_names())\r\n['universidades']\r\n\r\nPara acessar os documentos de uma coleção (aqui só imprimi o primeiro documento para não ficar bagunçado)\r\n\r\nuniversidades = db.universidades.find()\r\nprint(list(universidades)[1])\r\n{'_id': ObjectId('60429bd538dfd69aa3aa2d58'), 'nome': 'UNB', 'n_alunos': 20000}\r\n\r\nPara filtrar um documento\r\n\r\nnome = db.universidades.find({'n_alunos':20000})\r\nprint(list(nome))\r\n[{'_id': ObjectId('60429bd538dfd69aa3aa2d58'), 'nome': 'UNB', 'n_alunos': 20000}]\r\n\r\nPara inserir somente um documento\r\n\r\nwith con:\r\n\r\n    db = con.instituicoes\r\n    \r\n    db.universidades.insert_one({'nome': 'UFRJ', 'n_alunos': 25000})\r\n<pymongo.results.InsertOneResult object at 0x000000004E4C2A80>\r\n\r\nPara excluir uma coleção\r\n\r\ndb.universidades.drop()\r\n\r\nPara excluir um bd\r\n\r\ncon.drop_database('vendas_automoveis')\r\n\r\nListar os nomes dos bancos de dados:\r\n\r\ncon.list_database_names()\r\n['Vendas', 'admin', 'config', 'igti', 'local']\r\n\r\nExemplo de aplicação\r\nNada melhor que um exemplo prático, com dados reais para melhor entendimento do funcionamento da biblioteca.\r\nDados utilizados\r\nOs dados para o exemplo foram obtidos do Portal Brasileiro de Dados Abertos.\r\nNome do conjunto de dados: Vendas de veículos pelas concessionárias - Automóveis\r\nConceito: Valor da produção de veículos automotores no País. Refletem o desempenho das vendas das empresas associadas a(o): estoque e venda de veículos pelas concessionárias produção e vendas de veículos e congêneres produção e vendas de motociclos\r\nFonte: Federação Nacional da Distribuição de Veículos Automotores\r\nURL: http://api.bcb.gov.br/dados/serie/bcdata.sgs.7384/dados?formato=json\r\nVariáveis no dataset:\r\n          data: Data no formato “dd/mm/yyyy”, primeiro dia do mês.\r\n          valor: Número de unidades vendidas na data (mês)\r\nCódigos\r\nImportar as bibliotecas para obtenção dos dados\r\n\r\nimport pandas as pd\r\nimport requests\r\nimport json\r\nimport datetime\r\n\r\nRequisição GET para obter os dados no formato JSON.\r\n\r\nr = requests.get(url='https://api.bcb.gov.br/dados/serie/bcdata.sgs.7384/dados?formato=json')\r\n\r\nVisualizar os primeiros dois documentos do arquivo.\r\n\r\nr.json()[0:2]\r\n[{'data': '01/01/1990', 'valor': '52233'}, {'data': '01/02/1990', 'valor': '41228'}]\r\n\r\nDeleta o BD ‘vendas_automoveis’ que será criado novamente no próximo bloco.\r\n\r\ncon.drop_database('vendas_automoveis')\r\n\r\nCria o BD e a coleção para inserir os dados no BD\r\n\r\nnovo_bd = con['vendas_automoveis']\r\nnova_colecao = novo_bd['vendas']\r\n\r\nConecta novamente o BD, a coleção vendas e insere os dados JSON coletados no BD.\r\n\r\ndb = con['vendas_automoveis']\r\n# Carrega o bd\r\nvendas = db.vendas\r\nresultado = vendas.insert_many(r.json())\r\n\r\nBusca os dados do BD e configura os campos de data como datetime e o de valor como número.\r\n\r\ndf = pd.DataFrame(list(vendas.find()))\r\ndf['data'] = pd.to_datetime(df['data'], dayfirst=True)\r\ndf['valor'] = pd.to_numeric(df['valor'])\r\ndf.head()\r\n\r\n\r\n    .dataframe tbody tr th:only-of-type {\r\n        vertical-align: middle;\r\n    }\r\n\r\n    .dataframe tbody tr th {\r\n        vertical-align: top;\r\n    }\r\n\r\n    .dataframe thead th {\r\n        text-align: right;\r\n    }\r\n\r\n      _id\r\n      data\r\n      valor\r\n    0\r\n      60429bdd38dfd69aa3aa2d5c\r\n      1990-01-01\r\n      52233\r\n    1\r\n      60429bdd38dfd69aa3aa2d5d\r\n      1990-02-01\r\n      41228\r\n    2\r\n      60429bdd38dfd69aa3aa2d5e\r\n      1990-03-01\r\n      24353\r\n    3\r\n      60429bdd38dfd69aa3aa2d5f\r\n      1990-04-01\r\n      23705\r\n    4\r\n      60429bdd38dfd69aa3aa2d60\r\n      1990-05-01\r\n      44062\r\n    \r\n\r\n\r\nBack to top\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-05-pymongo/pymongo_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-03-11T20:08:24-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-imagementrada/",
    "title": "Imagem de entrada",
    "description": "Descreve a imagem de entrada da pagina inicial.",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-02-16",
    "categories": [
      "GGplot2",
      "R",
      "Visualizacao"
    ],
    "contents": "\r\nA imagem da entrada foi pensada para ilustrar minha página pessoal. O objetivo foi estabelecer a relação entre a ciência de dados, a matemática e a visualização de dados, destaques que pretendo dar ao site.\r\nA imagem é um ggplot de uma função de onda. Para isso, criei uma sequencia de dados que chamei de ‘x’ e criei outras duas variáveis ‘y’ e ‘z’, que são o resultado de diferentes funções. As funções foram anotadas no próprio gráfico de acordo com a cor da linha que ela representa.\r\nPacotes utilizados\r\n\r\n\r\nlibrary(ggplot2)\r\nlibrary(ggthemes)\r\nlibrary(extrafont)\r\nloadfonts(device = \"win\")\r\n\r\n\r\n\r\nCriação dos dados\r\n\r\n\r\nx = 1:1000\r\ny =  cos(2*pi*(1/2 - x/500))\r\nz =  cos(2*pi*(1/2 - x/250))\r\nlegenda_x <- \"cos(2 * pi * (frac(1,2) - frac(x,lambda)))\"\r\nlegenda_z <- \"cos(2 * pi * (frac(1,2) - frac(x,lambda)))\"\r\n\r\ncor_linha_1 <- '#E84B00'\r\ncor_linha_2 <- '#0F4ABF'\r\n\r\n\r\n\r\nElaboração do gráfico\r\n\r\n\r\n       ggplot(data = NULL) +\r\n   \r\n                geom_point(aes(x = 100, y = 1.6), col = \"transparent\") +\r\n                geom_point(aes(x = 100, y = -1.5), col = \"transparent\") +\r\n \r\n                geom_line(aes(x = x, y = y), lwd = 1.6, \r\n                          col = ifelse(x > 350 & x < 650,\r\n                                       alpha(cor_linha_1, alpha = 0.3), \r\n                                       alpha(cor_linha_1, alpha = 0.7))) +\r\n                geom_text(aes(x = 900, y = -1.2, label = legenda_x), \r\n                          parse = TRUE, col = alpha(cor_linha_1, alpha = 0.7), size = 8) +\r\n                \r\n                geom_line(aes(x = x, y = z), lwd = 1.6, \r\n                          col = ifelse(x > 350 & x < 650,\r\n                                       alpha(cor_linha_2, alpha = 0.3), \r\n                                       alpha(cor_linha_2, alpha = 0.7))) +\r\n                geom_text(aes(x = 100, y = 1.4, label = legenda_z), parse = TRUE,\r\n                          col = alpha(cor_linha_2, alpha = 0.7), size = 8) +\r\n                \r\n                annotate(\"text\", x = 500, y = 0, label = \"> LDN \\n + DS\",\r\n                         size = 28, family = \"Eras Bold ITC\", col = \"#236336\") +\r\n                \r\n                theme_map()\r\n\r\n\r\n\r\n\r\n\r\nBack to top\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-05-imagementrada/imagementrada_files/figure-html5/figura_entrada_post-1.png",
    "last_modified": "2021-03-11T21:35:39-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-menodistancia/",
    "title": "Distancia hidrica",
    "description": "Menor distancia entre dois pontos em um rio",
    "author": [
      {
        "name": "Leonardo Donato Nunes",
        "url": "https://github.com/LeonardoDonatoNunes"
      }
    ],
    "date": "2021-02-16",
    "categories": [
      "SIG",
      "R",
      "Visualizacao"
    ],
    "contents": "\r\nMenor caminho entre dois pontos\r\nEste documento foi criado para auxiliar quem precisa encontrar o menor caminho entre dois ou mais pontos dentro de um polígono, levando em consideração os limítes da área.\r\nComo exemplo, criei um polígono de rio, que contém ilhas e curvas. O objetivo é criar um caminho entre as ilhas e curvas que ligue dois pontos (como apresentado na Figura 1). Os pontos podem estar em um arquivo .csv  ou em um outro arquivo .shp . Neste caso preferi copiar as coordenadas para ter menos arquivos de entrada. selecionei um trecho de rio qualquer (não fiz questão de registrar o nome do rio para não desviar a atenção), criei um arquivo .shp  e desenhei o contorno do rio e depois criei os buracos das ilhas (as ilhas não existiam no rio, eu inventei). Para criação do polígono utilizei o software QGIS.\r\n\r\nPacotes\r\nPacotes para o tratamento dos dados:\r\n\r\n\r\nlibrary(raster)\r\nlibrary(gdistance)\r\nlibrary(dplyr)\r\nlibrary(rgdal)\r\n\r\n\r\n\r\nPacotes para para o processamento dos dados geográficos e ciração do mapa.\r\n\r\n\r\nlibrary(ggplot2)\r\nlibrary(ggthemes)\r\nlibrary(ggsn)\r\nlibrary(ggspatial)\r\nlibrary(sf)\r\n\r\n\r\n\r\nCarregar os dados\r\nO primeiro passo é carregar o polígono do rio, para isso, utilisei a função “shapefile” do pacote “raster”. Depois armazenei os pontos de origem e de destino em duas variáveis. Preferi copiar as coordenadas para ter um arquivo de entrada a menos. Mas essas coordenadas poderiam estar em um arquivo ou em outra camada.\r\n\r\n\r\n# Carrega o poligono do rio no formato .shp\r\nrio <- shapefile(\"rio.shp\")\r\n\r\n# Cria dois pontos que para serem conectados\r\norigem <- c(-49.16760,-20.30495)\r\ndestino <- c(-48.75058,-20.15693)\r\n\r\n\r\n\r\nGrid e raster\r\nEm seguida é necessário criar uma camada no formato raster que será utilizada para criar a camada de transição. Para isso será necessário escolher o tamanho das células do grid. Lembrando que o tamanho é muito particular, dependende do nível de detalhes necessário para que toda a área contenha células.\r\n\r\n\r\n# Cria o grid na área do polígono\r\ngrid <- makegrid(rio, cellsize = 0.0005)\r\n\r\n# O grid é um data.frame. para transformar em um  \r\n# conjunto de dados espaciais utiliza-se a funcao SpatialPoints\r\ngrid <- SpatialPoints(grid, proj4string = CRS(proj4string(rio)))\r\n\r\n# Extrair somente a parte do grid que intersepta o poligono do rio\r\ngrid <- grid[rio, ]\r\n\r\n# Converte o grid novamente em um data.frame para criacaodo raster\r\ngrid_df <- as.data.frame(grid)\r\n\r\n# Atribui um valor para as celulas que estao no rio (agua)\r\ngrid_df$value <- 1\r\n\r\n# Cria o raser do data.frame\r\nrio_raster <- rasterFromXYZ(grid_df)\r\n\r\nplot(rio_raster)\r\npoints(x = -48.70708, y = -22.17826, col = \"red\", cex = 4)\r\n\r\n\r\n\r\n\r\nCamada de transição\r\nPara criar o caminho em um raster é necessário que seja criado uma camada de transição. Para isso, utilizei a função “transition”, do pacote “gdistance”. Para quem já possui um raster da área desejada, ou preferiu criar o raster com outro software, basta carregar o raster a partir desta etapa.\r\n\r\n\r\n# Transforma o raster em uma camada de transição\r\nrio_tr <- transition(rio_raster, mean, directions = 8)\r\nrio_tr <- geoCorrection(rio_tr, \"c\")\r\n\r\n\r\n\r\nO menor caminho é criado com a função ‘shortestPath’ também do pacote ‘ggdistance’. Utilizei a função CRS para assinar um crs ao caminho.\r\n\r\n\r\n# Função que cria o menor caminho (pacote gdistance)\r\ncaminho <- shortestPath(rio_tr, origem, destino, output = \"SpatialLines\")\r\ncrs(caminho) <- CRS(\"+proj=longlat +datum=WGS84\")\r\n\r\n\r\n\r\nA seguir a instruçao de como foi feito o plot que é apresentado na introdução.\r\n\r\n\r\n# Função que cria o menor caminho (pacote gdistance)\r\ncaminho <- shortestPath(rio_tr, origem, destino, output = \"SpatialLines\")\r\n\r\ncrs(caminho) <- CRS(\"+proj=longlat +datum=WGS84\")\r\n\r\nlabel_compr <- paste0(\"Distância calculada: \",\r\n                      round(SpatialLinesLengths(caminho), 2), \" km\")\r\n\r\nrio <- st_as_sf(rio)\r\ncaminho <- st_as_sf(caminho, crs = CRS('+proj=longlat +datum=WGS84'))\r\n\r\n\r\n# Armazena os limites da área do rio para rosa dos ventos \r\nxmin <- extent(rio)[1]\r\nxmax <- extent(rio)[2]\r\nymin <- extent(rio)[3]\r\nymax <- extent(rio)[4]\r\n\r\nggplot() +\r\n  geom_sf(data = rio, fill = \"lightblue\", color = \"lightblue\") +\r\n  # Dados dos peixes\r\n  geom_sf(data = caminho, col = \"orange\", lwd = 2) +\r\n  \r\n  geom_point(data = NULL, aes(x = origem[1],\r\n                              y = origem[2]), \r\n             col = \"red\", size = 5) +\r\n  geom_text(data = NULL, aes(x = origem[1],\r\n                             y = origem[2],\r\n                             label = \"Origem\"),\r\n            size = 5, vjust = 3) +\r\n  \r\n  geom_point(data = NULL, aes(x = destino[1], \r\n                              y = destino[2]),\r\n             col = \"green\", size = 5) +\r\n  geom_text(data = NULL, aes(x = destino[1],\r\n                             y = destino[2], \r\n                             label = \"Destino\"), \r\n            size = 5, vjust = 2) +\r\n  \r\n  scalebar(dist = 5, dist_unit = \"km\", \r\n           x.min =  xmin, x.max = xmax, y.min = ymin, y.max = ymax,\r\n           transform = T, model = \"WGS84\", location = \"bottomright\", \r\n           st.dist = 0.05, st.color = \"grey50\",\r\n           box.fill = c(\"grey50\", \"white\")) +\r\n  north(x.min =  xmin, x.max = xmax, y.min = ymin, y.max = ymax,\r\n        scale = 0.12, anchor = c(x = -48.75, y = -20.39), symbol = 4) +\r\n  \r\n  annotate(\"text\", x = -49, y = -20.43, label = label_compr, size = 5) +\r\n  \r\n  ylab(\"\") +\r\n  xlab(\"\") +\r\n  \r\n  theme_map()\r\n\r\n\r\n\r\n\r\n\r\nDistância hidrica\r\nPara calcular a distância hídrica utilizei a fução “SpatialLinesLengths” do pacote “sp”. Importante notar que foi utilizado o argumento “latlong = T”, para retornar a distância em km.\r\n\r\n\r\ncaminho <- shortestPath(rio_tr, origem, destino, output = \"SpatialLines\")\r\ncrs(caminho) <- CRS(\"+proj=longlat +datum=WGS84\")\r\nSpatialLinesLengths(caminho, longlat = T)\r\n\r\n\r\n[1] 100.4559\r\n\r\n\r\nBrasil, 16 de Fevereiro de 2021\r\n\r\nBack to top\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-05-menodistancia/menodistancia_files/figure-html5/plot_caminho_intro-1.png",
    "last_modified": "2021-03-11T20:08:24-03:00",
    "input_file": {}
  }
]
